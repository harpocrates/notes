
// use note;

extern crate getopts;
extern crate rustc_serialize;
extern crate open;
extern crate rand;
extern crate bincode;

use bincode::SizeLimit;
use bincode::rustc_serialize::{encode_into, decode_from};
use getopts::Options;
use std::env;
use std::collections::HashSet;
use std::fs::File;
use std::path::Path;



#[derive(PartialEq, Eq, RustcEncodable, RustcDecodable)]
struct Note {
    id: usize,
    title: String,
    tags: HashSet<String>,
    body: String
}

impl Note {
    fn open(&self) -> () {
        if !open::that(AsRef::<std::ffi::OsStr>::as_ref(&self.body)).is_ok() {
            println!("Failed to open note.");
        }
    }
}

// Load notes from cache
fn load_from_cache(location: &Path) -> Option<Vec<Note>> {
    File::open(location).ok()
        .and_then(|mut file| decode_from(&mut file, SizeLimit::Infinite).ok())
}

// Write notes to cache
fn write_to_cache(existing: &Vec<Note>, location: &Path) -> Option<()> {
    File::create(location).ok()
        .and_then(|mut file| encode_into(existing, &mut file, SizeLimit::Infinite).ok())
}



fn main() {

    // let n = Note { id: rand::random::<usize>()
    //                title: String::from("Title"),
    //                tags: HashSet::new(),
    //                body: String::from("C:\\Users\\atheriault\\Desktop\\1.md") //Path::new("C:\\Users\\atheriault\\Desktop\\1.md")
    //              };
    // n.open()

    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        println!("Not enough args."); // TODO print avaiable options
        return
    }


    match args[1].as_str() {
        "new" => new_note(args),
        // "open" => expr,
        "help" | _ => println!("Unimplemented") // TODO print avaiable options
    };

}



fn new_note(args: Vec<String>) -> () {

    // Options for creating a note
    let mut opts = Options::new();
    opts.reqopt("t","title", "title of the note", "TITLE");
    opts.optopt("a","tags", "tags for the note, comma delimited", "TAGS");
    opts.reqopt("i", "input", "set input path", "FILE");

    let matches = match opts.parse(&args[2..]) {
        Ok(m) => m,
        Err(f) => {
            println!("{}", f.to_string());
            print!("{}", opts.usage("notes new"));
            return
        }
    };

    // create the note
    let tags: HashSet<String> = match matches.opt_str("tags") {
        Some(ts) => ts.split(",").map(|t| String::from(t.trim())).collect(),
        None => HashSet::new()
    };
    let note = Note { id: rand::random()
                    , title: matches.opt_str("title").unwrap()
                    , tags: tags
                    , body: matches.opt_str("input").unwrap()
                    };

    // Update the cache
    match env::home_dir() {
        None => { println!("Can't find home directory!"); return }
        Some(mut home) => {
            home.push(".notes-cache");
            let path = home.as_path();

            let mut cache: Vec<Note> = load_from_cache(path).unwrap_or(Vec::new());
            cache.push(note);
            write_to_cache(&cache, path);

            println!("{}", cache.len())
        }
    }
    
    
}